df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptHerfNoRFSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptHerfNoRFSRAn$datesTest
wOptHerfNoRFSRAn
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xHerfNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xHerfNoRFVarEval[[t]] <- foreach(sentixGroup = names(sHerf), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptHerfNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xHerfNoRFVarEval[[t]]) <- names(sHerf)
}
stopCluster(cl)
# names(xHerfVarTest) <- datesTestNames
saveRDS(xHerfNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
head(xHerfNoRFVarEval$datesEvalBear$P1$x)
saveRDS(xHerfNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfNoRFMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
datesEvalNames
sDisp <- list()
colnames(sentixRaw[[1]])
groupP <- c("P+", "Pn", "P-")
groupI <- c("I+", "In", "I-")
groupG <- c("G+", "Gn", "G-")
sDispColumn <- function(dat, group){
res <- numeric(nrow(dat))
for(i in 1:length(res)){
res[i] <- var(c(rep(1, dat[i, group[1]]), rep(0, dat[i, group[2]]), rep(-1, dat[i, group[3]])))
}
return(res)
}
names(sentixRaw)
(period1 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+1])
(period6 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+2])
sDispDataFrame <- function(period, group){
res <- data.frame(Datum = datesAll)
res$DAX <- sDispColumn(sentixRaw[[period[1]]], group)
res$TEC <- sDispColumn(sentixRaw[[period[2]]], group)
res$ESX50 <- sDispColumn(sentixRaw[[period[3]]], group)
res$SP5 <- sDispColumn(sentixRaw[[period[4]]], group)
res$NASDAQ <- sDispColumn(sentixRaw[[period[5]]], group)
res$NIKKEI <- sDispColumn(sentixRaw[[period[6]]], group)
res$BUND <- sDispColumn(sentixRaw[[period[7]]], group)
return(res)
}
sDisp[["P1"]] <- sDispDataFrame(period1, groupP)
sDisp[["P6"]] <- sDispDataFrame(period6, groupP)
sDisp[["I1"]] <- sDispDataFrame(period1, groupI)
sDisp[["I6"]] <- sDispDataFrame(period6, groupI)
sDisp[["G1"]] <- sDispDataFrame(period1, groupG)
sDisp[["G6"]] <- sDispDataFrame(period6, groupG)
# we get a problem as the helping formulas are hard coded
if((ncol(sDisp[[1]])-1) != length(period1))
stop("Fatal error. Check 'sDispDataFrame'. number of Indices changed")
rm(groupP, groupI, groupG, sDispColumn,
period1, period6, sDispDataFrame)
sHerf <- list()
colnames(sentixRaw[[1]])
groupP <- c("P+", "Pn", "P-")
groupI <- c("I+", "In", "I-")
groupG <- c("G+", "Gn", "G-")
sHerfColumn <- function(dat, group){
res <- numeric(nrow(dat))
for(i in 1:length(res)){
s <- sum(dat[i, group])
res[i] <- -1*( (dat[i, group[1]]/s)^2 + 2*(dat[i, group[2]]/s)^2 + (dat[i, group[3]]/s)^2 )
}
return(res)
}
names(sentixRaw)
(period1 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+1])
(period6 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+2])
sHerfDataFrame <- function(period, group){
res <- data.frame(Datum = datesAll)
res$DAX <- sHerfColumn(sentixRaw[[period[1]]], group)
res$TEC <- sHerfColumn(sentixRaw[[period[2]]], group)
res$ESX50 <- sHerfColumn(sentixRaw[[period[3]]], group)
res$SP5 <- sHerfColumn(sentixRaw[[period[4]]], group)
res$NASDAQ <- sHerfColumn(sentixRaw[[period[5]]], group)
res$NIKKEI <- sHerfColumn(sentixRaw[[period[6]]], group)
res$BUND <- sHerfColumn(sentixRaw[[period[7]]], group)
return(res)
}
sHerf[["P1"]] <- sHerfDataFrame(period1, groupP)
sHerf[["P6"]] <- sHerfDataFrame(period6, groupP)
sHerf[["I1"]] <- sHerfDataFrame(period1, groupI)
sHerf[["I6"]] <- sHerfDataFrame(period6, groupI)
sHerf[["G1"]] <- sHerfDataFrame(period1, groupG)
sHerf[["G6"]] <- sHerfDataFrame(period6, groupG)
# we get a problem as the helping formulas are hard coded
if((ncol(sHerf[[1]])-1) != length(period1))
stop("Fatal error. Check 'sHerfDataFrame'. number of Indices changed")
rm(groupP, groupI, groupG, sHerfColumn,
period1, period6, sHerfDataFrame)
ret <- as.matrix(stocks[2:nrow(stocks),2:ncol(stocks)]/stocks[1:(nrow(stocks)-1),2:ncol(stocks)] - 1)
rownames(ret) <- stocks[2:nrow(stocks), 1]
mu <- colMeans(ret)
C <- cov(ret)
# sentixRaw <- lapply(sentixRaw, function(x) {x <- x[2:nrow(x), ]})
# sDisp <- lapply(sDisp, function(x) {x <- x[2:nrow(x), ]})
# sHerf <- lapply(sHerf, function(x) {x <- x[2:nrow(x), ]})
#
# stocks <- stocks[2:nrow(stocks), ]
# datesAll <- datesAll[2:nrow(datesAll)]
l <- 50
retWindow <- matrix(0, nrow = nrow(ret)-l+1, ncol = ncol(ret))
rownames(retWindow) <- rownames(ret)[l:nrow(ret)]
class(rownames(retWindow)) <- "Date"
for(i in 1:nrow(retWindow)){
retWindow[i,] <- apply(ret[i:(i+l-1),]+1, 2, function(x) prod(x)-1) # 2 -> columnwise
}
retTotal <- numeric(nrow(retWindow))
retTotal <- apply(retWindow, 1, mean) # 1 -> rowwise
names(retTotal) <- rownames(retWindow)
iMin <- which(retTotal==min(retTotal))
iMax <- which(retTotal==max(retTotal))
# dates of which the returns have been calculated
datesEvalBear <- rownames(ret)[(iMin):(iMin+l-1)]
datesEvalBull <- rownames(ret)[(iMax):(iMax+l-1)]
class(datesEvalBear) <- "Date"
class(datesEvalBull) <- "Date"
plot(retTotal, type = "l", axes = FALSE, main = "returns over the time window")
abline(v = iMin, col = "red", lwd = 2)
abline(v = iMax, col = "green", lwd = 2)
axis(1, pretty(1:length(retTotal)), names(retTotal)[pretty(1:length(retTotal))+1])
axis(2)
datesEvalLast <- rownames(ret)[(nrow(ret)-l+1):nrow(ret)]
class(datesEvalLast) <- "Date"
startDateTest <- 50
timeBefore <- 50
( startEvalTime <- which(datesAll == min(c(min(datesEvalBear), min(datesEvalBull), min(datesEvalLast)))) )
datesTest <- rownames(ret)[startDateTest:(startEvalTime-timeBefore)]
class(datesTest) <- "Date"
length(datesTest)
datesEvalAllAfterTest <- rownames(ret)[(max(which(rownames(ret) %in% datesTest))+1):nrow(ret)]
class(datesEvalAllAfterTest) <- "Date"
tmp <- rownames(ret)
class(tmp) <- "Date"
tmp <- as.character(tmp)
datesEvalRecNBER <- rownames(ret)[min(which(substring(tmp, 1,7) == "2007-12")):max(which(substring(tmp, 1, 7) == "2009-06"))]
class(datesEvalRecNBER) <- "Date"
datesEvalNames <- c(deparse(substitute(datesEvalBear)), deparse(substitute(datesEvalRecNBER)), deparse(substitute(datesEvalBull)), deparse(substitute(datesEvalLast)), deparse(substitute(datesEvalAllAfterTest)))
datesTestNames <- c(deparse(substitute(datesTest)))
rm(l, i)
rm(retWindow, retTotal)
rm(iMin, iMax, startDateTest, startEvalTime, timeBefore)
datesEvalNames
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xHerfNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xHerfNoRFVarEval[[t]] <- foreach(sentixGroup = names(sHerf), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptHerfNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xHerfNoRFVarEval[[t]]) <- names(sHerf)
}
stopCluster(cl)
# names(xHerfVarTest) <- datesTestNames
saveRDS(xHerfNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfNoRFMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
xHerfNoRFVarEval <- readRDS(file.path(getwd(), "Optimization", "EHerfNoRFMinVaryingEval_gloggest2017-09-06---14-00"))
head(xHerfNoRFVarEval$datesEvalBear$P1$x)
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xDispNoRFVarTest <- list()
registerDoSNOW(cl)
for(t in datesTestNames){
xDispNoRFVarTest[[t]] <- foreach(i = names(sDisp), .export = c(datesTestNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
for(weightInd in 1:nrow(grid)){
w <- unlist(grid[weightInd,])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
L[[paste(w, collapse = "-")]] <- list(x = mat, obj = obj, time = tim)
print(weightInd/nrow(grid))
}
L
}
names(xDispNoRFVarTest[[t]]) <- names(sDisp)
}
hDispDirectMin <- function(x){
y <- numeric(3)
y[1] <- -1.0 * w[1] * drop(crossprod(x, anMuOpt)) / targetRpa
y[2] <- w[2] * drop(sqrt(t(x) %*% anCOpt %*% x)) * sqrt(12) / targetVolpa
y[3] <- w[3] * drop(crossprod(x, anDOpt)) / targetDisp
return(sum(y))
}
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xDispNoRFVarTest <- list()
registerDoSNOW(cl)
for(t in datesTestNames){
xDispNoRFVarTest[[t]] <- foreach(i = names(sDisp), .export = c(datesTestNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
for(weightInd in 1:nrow(grid)){
w <- unlist(grid[weightInd,])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
L[[paste(w, collapse = "-")]] <- list(x = mat, obj = obj, time = tim)
print(weightInd/nrow(grid))
}
L
}
names(xDispNoRFVarTest[[t]]) <- names(sDisp)
}
saveRDS(xDispNoRFVarTest, file = file.path(getwd(), "Optimization", paste0("EDispersionMinVaryingTest_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
stopCluster(cl)
head(xDispNoRFVarTest$datesTest$P1$`0.9-0.05-0.05`$x)
tail(xDispNoRFVarTest$datesTest$P1$`0.9-0.05-0.05`$x)
head(xDispNoRFVarTest$datesTest$P1$`0.9-0.05-0.05`$x)
xDispNoRFVarTest <- readRDS(file.path(getwd(), "Optimization", "EDispersionMinVaryingTest_gloggest2017-09-06---14-13"))
xDispNoRFVarTestCalc <- calcTestVar(xDispNoRFVarTest)
srWeightsAn <- extractWeightsWithValue(xDispNoRFVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Dispersion-No-Risk-Free")
wOptDispSRAn <- list()
for(timeWindowName in names(srWeightsAn)){
for(sentixGroup in names(srWeightsAn[[timeWindowName]])){
df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptDispSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptDispSRAn$datesTest
rm(xDispNoRFVarTest, xDispNoRFVarTestCalc)
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xDispNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xDispNoRFVarEval[[t]] <- foreach(sentixGroup = names(sDisp), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptDispNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xDispNoRFVarEval[[t]]) <- names(sDisp)
}
wOptDispNoRFSRAn <- list()
for(timeWindowName in names(srWeightsAn)){
for(sentixGroup in names(srWeightsAn[[timeWindowName]])){
df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptDispNoRFSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptDispNoRFSRAn$datesTest
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xDispNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xDispNoRFVarEval[[t]] <- foreach(sentixGroup = names(sDisp), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptDispNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xDispNoRFVarEval[[t]]) <- names(sDisp)
}
stopCluster(cl)
# names(xDispVarTest) <- datesTestNames
saveRDS(xDispNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EDispersionMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
head(xDispNoRFVarEval$datesEvalBear$P1$x)

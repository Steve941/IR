<<<<<<< HEAD
df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptHerfNoRFSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptHerfNoRFSRAn$datesTest
wOptHerfNoRFSRAn
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xHerfNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xHerfNoRFVarEval[[t]] <- foreach(sentixGroup = names(sHerf), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptHerfNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xHerfNoRFVarEval[[t]]) <- names(sHerf)
}
stopCluster(cl)
# names(xHerfVarTest) <- datesTestNames
saveRDS(xHerfNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
head(xHerfNoRFVarEval$datesEvalBear$P1$x)
saveRDS(xHerfNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfNoRFMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
datesEvalNames
sDisp <- list()
colnames(sentixRaw[[1]])
groupP <- c("P+", "Pn", "P-")
groupI <- c("I+", "In", "I-")
groupG <- c("G+", "Gn", "G-")
sDispColumn <- function(dat, group){
res <- numeric(nrow(dat))
for(i in 1:length(res)){
res[i] <- var(c(rep(1, dat[i, group[1]]), rep(0, dat[i, group[2]]), rep(-1, dat[i, group[3]])))
}
return(res)
}
names(sentixRaw)
(period1 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+1])
(period6 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+2])
sDispDataFrame <- function(period, group){
res <- data.frame(Datum = datesAll)
res$DAX <- sDispColumn(sentixRaw[[period[1]]], group)
res$TEC <- sDispColumn(sentixRaw[[period[2]]], group)
res$ESX50 <- sDispColumn(sentixRaw[[period[3]]], group)
res$SP5 <- sDispColumn(sentixRaw[[period[4]]], group)
res$NASDAQ <- sDispColumn(sentixRaw[[period[5]]], group)
res$NIKKEI <- sDispColumn(sentixRaw[[period[6]]], group)
res$BUND <- sDispColumn(sentixRaw[[period[7]]], group)
return(res)
}
sDisp[["P1"]] <- sDispDataFrame(period1, groupP)
sDisp[["P6"]] <- sDispDataFrame(period6, groupP)
sDisp[["I1"]] <- sDispDataFrame(period1, groupI)
sDisp[["I6"]] <- sDispDataFrame(period6, groupI)
sDisp[["G1"]] <- sDispDataFrame(period1, groupG)
sDisp[["G6"]] <- sDispDataFrame(period6, groupG)
# we get a problem as the helping formulas are hard coded
if((ncol(sDisp[[1]])-1) != length(period1))
stop("Fatal error. Check 'sDispDataFrame'. number of Indices changed")
rm(groupP, groupI, groupG, sDispColumn,
period1, period6, sDispDataFrame)
sHerf <- list()
colnames(sentixRaw[[1]])
groupP <- c("P+", "Pn", "P-")
groupI <- c("I+", "In", "I-")
groupG <- c("G+", "Gn", "G-")
sHerfColumn <- function(dat, group){
res <- numeric(nrow(dat))
for(i in 1:length(res)){
s <- sum(dat[i, group])
res[i] <- -1*( (dat[i, group[1]]/s)^2 + 2*(dat[i, group[2]]/s)^2 + (dat[i, group[3]]/s)^2 )
}
return(res)
}
names(sentixRaw)
(period1 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+1])
(period6 <- names(sentixRaw)[2*((0:(length(sentixRaw)/2-1)))+2])
sHerfDataFrame <- function(period, group){
res <- data.frame(Datum = datesAll)
res$DAX <- sHerfColumn(sentixRaw[[period[1]]], group)
res$TEC <- sHerfColumn(sentixRaw[[period[2]]], group)
res$ESX50 <- sHerfColumn(sentixRaw[[period[3]]], group)
res$SP5 <- sHerfColumn(sentixRaw[[period[4]]], group)
res$NASDAQ <- sHerfColumn(sentixRaw[[period[5]]], group)
res$NIKKEI <- sHerfColumn(sentixRaw[[period[6]]], group)
res$BUND <- sHerfColumn(sentixRaw[[period[7]]], group)
return(res)
}
sHerf[["P1"]] <- sHerfDataFrame(period1, groupP)
sHerf[["P6"]] <- sHerfDataFrame(period6, groupP)
sHerf[["I1"]] <- sHerfDataFrame(period1, groupI)
sHerf[["I6"]] <- sHerfDataFrame(period6, groupI)
sHerf[["G1"]] <- sHerfDataFrame(period1, groupG)
sHerf[["G6"]] <- sHerfDataFrame(period6, groupG)
# we get a problem as the helping formulas are hard coded
if((ncol(sHerf[[1]])-1) != length(period1))
stop("Fatal error. Check 'sHerfDataFrame'. number of Indices changed")
rm(groupP, groupI, groupG, sHerfColumn,
period1, period6, sHerfDataFrame)
ret <- as.matrix(stocks[2:nrow(stocks),2:ncol(stocks)]/stocks[1:(nrow(stocks)-1),2:ncol(stocks)] - 1)
rownames(ret) <- stocks[2:nrow(stocks), 1]
mu <- colMeans(ret)
C <- cov(ret)
# sentixRaw <- lapply(sentixRaw, function(x) {x <- x[2:nrow(x), ]})
# sDisp <- lapply(sDisp, function(x) {x <- x[2:nrow(x), ]})
# sHerf <- lapply(sHerf, function(x) {x <- x[2:nrow(x), ]})
#
# stocks <- stocks[2:nrow(stocks), ]
# datesAll <- datesAll[2:nrow(datesAll)]
l <- 50
retWindow <- matrix(0, nrow = nrow(ret)-l+1, ncol = ncol(ret))
rownames(retWindow) <- rownames(ret)[l:nrow(ret)]
class(rownames(retWindow)) <- "Date"
for(i in 1:nrow(retWindow)){
retWindow[i,] <- apply(ret[i:(i+l-1),]+1, 2, function(x) prod(x)-1) # 2 -> columnwise
}
retTotal <- numeric(nrow(retWindow))
retTotal <- apply(retWindow, 1, mean) # 1 -> rowwise
names(retTotal) <- rownames(retWindow)
iMin <- which(retTotal==min(retTotal))
iMax <- which(retTotal==max(retTotal))
# dates of which the returns have been calculated
datesEvalBear <- rownames(ret)[(iMin):(iMin+l-1)]
datesEvalBull <- rownames(ret)[(iMax):(iMax+l-1)]
class(datesEvalBear) <- "Date"
class(datesEvalBull) <- "Date"
plot(retTotal, type = "l", axes = FALSE, main = "returns over the time window")
abline(v = iMin, col = "red", lwd = 2)
abline(v = iMax, col = "green", lwd = 2)
axis(1, pretty(1:length(retTotal)), names(retTotal)[pretty(1:length(retTotal))+1])
axis(2)
datesEvalLast <- rownames(ret)[(nrow(ret)-l+1):nrow(ret)]
class(datesEvalLast) <- "Date"
startDateTest <- 50
timeBefore <- 50
( startEvalTime <- which(datesAll == min(c(min(datesEvalBear), min(datesEvalBull), min(datesEvalLast)))) )
datesTest <- rownames(ret)[startDateTest:(startEvalTime-timeBefore)]
class(datesTest) <- "Date"
length(datesTest)
datesEvalAllAfterTest <- rownames(ret)[(max(which(rownames(ret) %in% datesTest))+1):nrow(ret)]
class(datesEvalAllAfterTest) <- "Date"
tmp <- rownames(ret)
class(tmp) <- "Date"
tmp <- as.character(tmp)
datesEvalRecNBER <- rownames(ret)[min(which(substring(tmp, 1,7) == "2007-12")):max(which(substring(tmp, 1, 7) == "2009-06"))]
class(datesEvalRecNBER) <- "Date"
datesEvalNames <- c(deparse(substitute(datesEvalBear)), deparse(substitute(datesEvalRecNBER)), deparse(substitute(datesEvalBull)), deparse(substitute(datesEvalLast)), deparse(substitute(datesEvalAllAfterTest)))
datesTestNames <- c(deparse(substitute(datesTest)))
rm(l, i)
rm(retWindow, retTotal)
rm(iMin, iMax, startDateTest, startEvalTime, timeBefore)
datesEvalNames
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xHerfNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xHerfNoRFVarEval[[t]] <- foreach(sentixGroup = names(sHerf), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptHerfNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xHerfNoRFVarEval[[t]]) <- names(sHerf)
}
stopCluster(cl)
# names(xHerfVarTest) <- datesTestNames
saveRDS(xHerfNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfNoRFMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
xHerfNoRFVarEval <- readRDS(file.path(getwd(), "Optimization", "EHerfNoRFMinVaryingEval_gloggest2017-09-06---14-00"))
head(xHerfNoRFVarEval$datesEvalBear$P1$x)
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xDispNoRFVarTest <- list()
registerDoSNOW(cl)
for(t in datesTestNames){
xDispNoRFVarTest[[t]] <- foreach(i = names(sDisp), .export = c(datesTestNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
for(weightInd in 1:nrow(grid)){
w <- unlist(grid[weightInd,])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
L[[paste(w, collapse = "-")]] <- list(x = mat, obj = obj, time = tim)
print(weightInd/nrow(grid))
}
L
}
names(xDispNoRFVarTest[[t]]) <- names(sDisp)
}
hDispDirectMin <- function(x){
y <- numeric(3)
y[1] <- -1.0 * w[1] * drop(crossprod(x, anMuOpt)) / targetRpa
y[2] <- w[2] * drop(sqrt(t(x) %*% anCOpt %*% x)) * sqrt(12) / targetVolpa
y[3] <- w[3] * drop(crossprod(x, anDOpt)) / targetDisp
return(sum(y))
}
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xDispNoRFVarTest <- list()
registerDoSNOW(cl)
for(t in datesTestNames){
xDispNoRFVarTest[[t]] <- foreach(i = names(sDisp), .export = c(datesTestNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
for(weightInd in 1:nrow(grid)){
w <- unlist(grid[weightInd,])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[i]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
L[[paste(w, collapse = "-")]] <- list(x = mat, obj = obj, time = tim)
print(weightInd/nrow(grid))
}
L
}
names(xDispNoRFVarTest[[t]]) <- names(sDisp)
}
saveRDS(xDispNoRFVarTest, file = file.path(getwd(), "Optimization", paste0("EDispersionMinVaryingTest_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
stopCluster(cl)
head(xDispNoRFVarTest$datesTest$P1$`0.9-0.05-0.05`$x)
tail(xDispNoRFVarTest$datesTest$P1$`0.9-0.05-0.05`$x)
head(xDispNoRFVarTest$datesTest$P1$`0.9-0.05-0.05`$x)
xDispNoRFVarTest <- readRDS(file.path(getwd(), "Optimization", "EDispersionMinVaryingTest_gloggest2017-09-06---14-13"))
xDispNoRFVarTestCalc <- calcTestVar(xDispNoRFVarTest)
srWeightsAn <- extractWeightsWithValue(xDispNoRFVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Dispersion-No-Risk-Free")
wOptDispSRAn <- list()
for(timeWindowName in names(srWeightsAn)){
for(sentixGroup in names(srWeightsAn[[timeWindowName]])){
df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptDispSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptDispSRAn$datesTest
rm(xDispNoRFVarTest, xDispNoRFVarTestCalc)
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xDispNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xDispNoRFVarEval[[t]] <- foreach(sentixGroup = names(sDisp), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptDispNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xDispNoRFVarEval[[t]]) <- names(sDisp)
}
wOptDispNoRFSRAn <- list()
for(timeWindowName in names(srWeightsAn)){
for(sentixGroup in names(srWeightsAn[[timeWindowName]])){
df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptDispNoRFSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptDispNoRFSRAn$datesTest
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xDispNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xDispNoRFVarEval[[t]] <- foreach(sentixGroup = names(sDisp), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptDispNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xDispNoRFVarEval[[t]]) <- names(sDisp)
}
stopCluster(cl)
# names(xDispVarTest) <- datesTestNames
saveRDS(xDispNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EDispersionMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
head(xDispNoRFVarEval$datesEvalBear$P1$x)
=======
}
lateximport <- c(lateximport, "\\clearpage")
fileConnection <- file(file.path(getwd(), "Plot", paste0("0",fileName,".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
retPortClassicVarying <- calcEvalVarClassicTradCost(xClassicVar)
retPortSentixVarying <- calcEvalVarClassicTradCost(xDispVarEval)
retPortHerfVarying <- calcEvalVarClassicTradCost(xHerfVarEval)
retAllVarying <- retPortClassicVarying
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortSentixVarying[[timeWindowName]])
}
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortHerfVarying[[timeWindowName]])
}
summaryTableDominik(retAllVarying, "SummaryDominik-classicNoRiskFree")
dat <- retAllVarying
datesWeWant <- c("datesEvalBear", "datesEvalRecNBER", "datesEvalBull", "datesEvalAllAfterTest")
tab <- matrix(0, nrow = 6*length(datesWeWant), ncol = 18)
rownames(tab) <- rep(c("Ret. (an)", "Vol. (an)", "SR (an)", "Omega", "VaR", "CoVaR"), 4)
for(d in datesWeWant){
datInside <- dat[[d]]
for(s in names(dat[[d]])){
tab[(which(datesWeWant == d)-1)+1, which(names(dat[[d]] == s))] = dat[[d]][[s]]
}
tab <- c(lateximport, print(xtable(summaryClassic(dat, d, roundTo)), floating = FALSE))
print(summaryClassic(dat, d, roundTo))
}
dat[[d]]
names(dat[[d]])
dat[[d]]
dat[[d]]$tanPort
summaryTableDominik <- function(dat, fileName, roundTo = 4){
datesWeWant <- c("datesEvalBear", "datesEvalRecNBER", "datesEvalBull", "datesEvalAllAfterTest")
tab <- matrix(0, nrow = 6*length(datesWeWant), ncol = 18)
rownames(tab) <- rep(c("Ret. (an)", "Vol. (an)", "SR (an)", "Omega", "VaR", "CoVaR"), 4)
for(d in datesWeWant){
datInside <- dat[[d]]
for(s in names(dat[[d]])){
tab[(which(datesWeWant == d)-1)+1, which(names(dat[[d]]) == s)] = dat[[d]][[s]]$sr
}
tab <- c(lateximport, print(xtable(summaryClassic(dat, d, roundTo)), floating = FALSE))
print(summaryClassic(dat, d, roundTo))
}
lateximport <- c(lateximport, "\\clearpage")
fileConnection <- file(file.path(getwd(), "Plot", paste0("0",fileName,".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
summaryTableDominik(retAllVarying, "SummaryDominik-classicNoRiskFree")
summaryTableDominik <- function(dat, fileName, roundTo = 4){
lateximport <- c(paste0("\\subsection{",fileName," - summaryTableDominik}"))
datesWeWant <- c("datesEvalBear", "datesEvalRecNBER", "datesEvalBull", "datesEvalAllAfterTest")
tab <- matrix(0, nrow = 6*length(datesWeWant), ncol = 18)
rownames(tab) <- rep(c("Ret. (an)", "Vol. (an)", "SR (an)", "Omega", "VaR", "CoVaR"), 4)
for(d in datesWeWant){
datInside <- dat[[d]]
for(s in names(dat[[d]])){
tab[(which(datesWeWant == d)-1)+1, which(names(dat[[d]]) == s)] = dat[[d]][[s]]$sr
}
tab <- c(lateximport, print(xtable(summaryClassic(dat, d, roundTo)), floating = FALSE))
print(summaryClassic(dat, d, roundTo))
}
lateximport <- c(lateximport, "\\clearpage")
fileConnection <- file(file.path(getwd(), "Plot", paste0("0",fileName,".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
summaryTableDominik(retAllVarying, "SummaryDominik-classicNoRiskFree")
summaryTableDominik <- function(dat, fileName, roundTo = 4){
lateximport <- c(paste0("\\subsection{",fileName," - summaryTableDominik}"))
datesWeWant <- c("datesEvalBear", "datesEvalRecNBER", "datesEvalBull", "datesEvalAllAfterTest")
tab <- matrix(0, nrow = 6*length(datesWeWant), ncol = 18)
rownames(tab) <- rep(c("Ret. (an)", "Vol. (an)", "SR (an)", "Omega", "VaR", "CoVaR"), 4)
for(d in datesWeWant){
datInside <- dat[[d]]
for(s in names(dat[[d]])){
tab[(which(datesWeWant == d)-1)+1, which(names(dat[[d]]) == s)] = dat[[d]][[s]]$sr
}
tab <- c(lateximport, print(xtable(summaryClassic(dat, d, roundTo)), floating = FALSE))
print(summaryClassic(dat, d, roundTo))
}
lateximport <- c(lateximport, "\\clearpage")
fileConnection <- file(file.path(getwd(), "Plot", paste0("0",fileName,".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
retPortClassicVarying <- calcEvalVarClassicTradCost(xClassicVar)
retPortSentixVarying <- calcEvalVarClassicTradCost(xDispVarEval)
retPortHerfVarying <- calcEvalVarClassicTradCost(xHerfVarEval)
retAllVarying <- retPortClassicVarying
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortSentixVarying[[timeWindowName]])
}
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortHerfVarying[[timeWindowName]])
}
summaryTableDominik(retAllVarying, "SummaryDominik-classicNoRiskFree")
install.packages("openxlsx")
install.packages("quantmod")
library(xtable)
# install.packages("openxlsx")
library(openxlsx)
install.packages("FSelector")
install.packages("Rdonlp2", repos="http://R-Forge.R-project.org")
install.packages("Rdonlp2", repos="https://svn.r-project.org/Rmetrics/trunk/Rdonlp2/")
colsEvalDates <- c("red", "darkred", "green", "orange", "yellow")
names(colsEvalDates) <- datesEvalNames
plotData <- function(x, title = "Indices", bw = FALSE){
if(bw){
}else{
# lines with data
geomLineDataDAX <- function(x){
parse(text = paste0("geom_line(data = ", x, ", aes(x = Datum, y = DAX, colour = \"DAX\"))"))
}
geomLineDataTEC <- function(x){
parse(text = paste0("geom_line(data = ", x, ", aes(x = Datum, y = TEC, colour = \"TEC\"))"))
}
geomLineDataESX50 <- function(x){
parse(text = paste0("geom_line(data = ", x, ", aes(x = Datum, y = ESX50, colour = \"ESX50\"))"))
}
geomLineDataSP5 <- function(x){
parse(text = paste0("geom_line(data = ", x, ", aes(x = Datum, y = SP5, colour = \"SP5\"))"))
}
geomLineDataNASDAQ <- function(x){
parse(text = paste0("geom_line(data = ", x, ", aes(x = Datum, y = NASDAQ, colour = \"NASDAQ\"))"))
}
geomLineDataNIKKEI <- function(x){
parse(text = paste0("geom_line(data = ", x, ", aes(x = Datum, y = NIKKEI, colour = \"NIKKEI\"))"))
}
geomLineDataBUND <- function(x){
parse(text = paste0("geom_line(data = ", x, ", aes(x = Datum, y = BUND, colour = \"BUND\"))"))
}
# rectangle for date period
geomRectDateBear <- function(){
parse(text = "geom_rect(aes(xmin = min(datesEvalBear), xmax = max(datesEvalBear), ymin = -Inf, ymax = Inf), alpha = 0.2 , fill = \"red\")")}
geomRectDateRecNBER <- function(){
parse(text = "geom_rect(aes(xmin = min(datesEvalRecNBER), xmax = max(datesEvalRecNBER), ymin = -Inf, ymax = Inf), alpha = 0.2 , fill = \"darkred\")")}
geomRectDateBull <- function(){
parse(text = "geom_rect(aes(xmin = min(datesEvalBull), xmax = max(datesEvalBull), ymin = -Inf, ymax = Inf), alpha = 0.2 , fill = \"green\")")}
# geomRectDateLast <- function(){
#   parse(text = "geom_rect(aes(xmin = min(datesEvalLast), xmax = max(datesEvalLast), ymin = -Inf, ymax = Inf), alpha = 0.2 , fill = \"orange\")")}
geomRectDateTest <- function(){
parse(text = "geom_rect(aes(xmin = min(datesTest), xmax = max(datesTest), ymin = -Inf, ymax = Inf), alpha = 0.2 , fill = \"blue\")")}
ggplot() +
eval(geomLineDataDAX(x)) +
eval(geomLineDataTEC(x)) +
eval(geomLineDataESX50(x)) +
eval(geomLineDataNASDAQ(x)) +
eval(geomLineDataNIKKEI(x)) +
eval(geomLineDataBUND(x)) +
# eval(geomRectDateLast()) +
eval(geomRectDateBear()) +
eval(geomRectDateRecNBER()) +
eval(geomRectDateBull()) +
eval(geomRectDateTest()) +
labs(x = "Time", y = "Value") +
labs(title = title) +
theme(plot.title = element_text(hjust = 0.5)) # align title in center
}
}
## if a special name is given, take it, otherwise take x (plot sentix by using same dataframe (adopted))
plotDataPDF <- function(x, xName = x){
pdf(file.path(getwd(), "Plot", paste0(xName, ".pdf")), width = 10, height = 4)
plot(plotData(x))
dev.off()
}
# ePlot <- new.env() # environment to store functions (doesn't work)
# ls.str(envir = ePlot)
# geomLineData <- function(x){
#     parse(text = paste0("eval(geomLineDataDAX(\"", x , "\")) + eval(geomLineDataTEC(\"", x , "\"))"))
# }
#
# ggplot() +
#     eval(geomLineData("retPlot")) +
#     eval(geomRectDateLast) +
#     labs(x = "Time", y = "Value")
retPlot <- matrix(100, nrow = nrow(stocks), ncol = ncol(stocks)-1)
retPlot[2:nrow(stocks), ] <- 1+ret # to multiply lateron, we have to add 1
retPlot <- apply(retPlot, 2, cumprod)
rownames(retPlot) <- stocks[,1]
xNames <- rownames(retPlot)
class(xNames) <- "Date"   # convert to date
cols <- rainbow(ncol(retPlot))
ylim <- c(min(retPlot), max(retPlot))
plot(xNames, retPlot[,1], type = "l", xlab = "Date", ylab = "Value", main = "Indices over time",
col = cols[1], ylim = ylim)
for(sentixGroup in 2:ncol(retPlot)){
par(new=T)
plot(xNames, retPlot[,sentixGroup], type = "l", col = cols[sentixGroup], axes = F, xlab="", ylab="", ylim = ylim)
}
legend("topleft", legend = colnames(stocks)[2:ncol(stocks)], col = cols, lty = 1)
rm(retPlot, xNames, ylim, sentixGroup)
library(ggplot2)
retPlot <- matrix(100, nrow = nrow(stocks), ncol = ncol(stocks)-1)
retPlot[2:nrow(stocks), ] <- 1+ret # to multiply lateron, we have to add 1
retPlot <- apply(retPlot, 2, cumprod)
retPlot <- as.data.frame(retPlot)
colnames(retPlot) <- colnames(stocks)[2:ncol(stocks)]
retPlot$Datum <- stocks[,1]
class(retPlot$Datum) <- "Date"   # convert to date
cols <- rainbow(ncol(retPlot))
ylim <- c(min(retPlot[,1:(ncol(retPlot)-1)]), max(retPlot[,1:(ncol(retPlot)-1)]))
plotData("retPlot")
plotDataPDF("retPlot")
retPlot <- matrix(100, nrow = nrow(stocks), ncol = ncol(stocks)-1)
retPlot[2:nrow(stocks), ] <- 1+ret # to multiply lateron, we have to add 1
retPlot <- apply(retPlot, 2, cumprod)
retPlot <- as.data.frame(retPlot)
colnames(retPlot) <- colnames(stocks)[2:ncol(stocks)]
retPlot$Datum <- stocks[,1]
class(retPlot$Datum) <- "Date"   # convert to date
cols <- rainbow(ncol(retPlot))
ylim <- c(min(retPlot[,1:(ncol(retPlot)-1)]), max(retPlot[,1:(ncol(retPlot)-1)]))
plotData("retPlot")
plotDataPDF("retPlot")
## plot Data Black White (print)
library(tidyverse)
install.packages("tidyverse")
## plot Data Black White (print)
library(tidyverse)
retPlotLong <- gather(retPlot, index, value, -Datum)
retPlotLong$index <- factor(retPlotLong$index)
bearMinMax <- data.frame("date" = c(min(datesEvalBear), max(datesEvalBear)))
RecNBERMinMax <- data.frame("date" = c(min(datesEvalRecNBER), max(datesEvalRecNBER)))
bullMinMax <- data.frame("date" = c(min(datesEvalBull), max(datesEvalBull)))
TestSplit <- data.frame("date" = min(datesEvalAllAfterTest))
pdf(file.path(getwd(), "Plot", paste0("retPlot", ".pdf")), width = 10, height = 4)
ggplot(retPlotLong, aes(x = Datum, y=value, col=index, linetype = index)) +
geom_line(lwd=1) +
scale_color_grey() +
scale_linetype_discrete() +
geom_vline(data = bearMinMax, aes(xintercept=as.numeric(date)),
linetype=4, colour="black") +
geom_vline(data = RecNBERMinMax, aes(xintercept=as.numeric(date)),
linetype=3, colour="black") +
geom_vline(data = bullMinMax, aes(xintercept=as.numeric(date)),
linetype=2, colour="black") +
geom_vline(data = TestSplit, aes(xintercept=as.numeric(date)),
linetype=1, colour="black") +
theme_bw()+
labs(x = "Time", y = "Value", colour = "Index", linetype = "Index")
dev.off()
# rm(retPlot, cols, ylim)
## plot Data Black White (print)
library(tidyverse)
library(ggtern)
retPlotLong <- gather(retPlot, index, value, -Datum)
retPlotLong$index <- factor(retPlotLong$index)
bearMinMax <- data.frame("date" = c(min(datesEvalBear), max(datesEvalBear)))
RecNBERMinMax <- data.frame("date" = c(min(datesEvalRecNBER), max(datesEvalRecNBER)))
bullMinMax <- data.frame("date" = c(min(datesEvalBull), max(datesEvalBull)))
TestSplit <- data.frame("date" = min(datesEvalAllAfterTest))
pdf(file.path(getwd(), "Plot", paste0("retPlot", ".pdf")), width = 10, height = 4)
ggplot(retPlotLong, aes(x = Datum, y=value, col=index)) +
geom_line(lwd=1) +
# scale_color_grey() +
geom_vline(data = bearMinMax, aes(xintercept=as.numeric(date)),
linetype=4, colour="black") +
geom_vline(data = RecNBERMinMax, aes(xintercept=as.numeric(date)),
linetype=3, colour="black") +
geom_vline(data = bullMinMax, aes(xintercept=as.numeric(date)),
linetype=2, colour="black") +
geom_vline(data = TestSplit, aes(xintercept=as.numeric(date)),
linetype=1, colour="black") +
theme_rgbg() +
# theme_bw()+
labs(x = "Time", y = "Value", colour = "Index")
dev.off()
# rm(retPlot, cols, ylim)
lateximport <- c(paste0("\\subsection{Dispersion}"))
for(sentixGroup in names(sDisp)){
title <- paste0("sDisp-", sentixGroup)
sPlot <- sDisp[[sentixGroup]]
plotDataPDF("sPlot", title)
lateximport <- c(lateximport, paste0("\\includegraphics[width=\\textwidth]{",paste0(title, ".pdf"),"}\\linebreak"))
}
fileConnection <- file(file.path(getwd(), "Plot", paste0("0sentixDisp.txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
rm(sPlot, sentixGroup, lateximport, fileConnection)
lapply(sDisp, function(x) {base::summary(x[,-1], digits = 2)})
lateximport <- c(paste0("\\subsection{Herfindahl}"))
for(sentixGroup in names(sHerf)){
title <- paste0("sHerf-", sentixGroup)
sPlot <- sHerf[[sentixGroup]]
plotDataPDF("sPlot", title)
lateximport <- c(lateximport, paste0("\\includegraphics[width=\\textwidth]{",paste0(title, ".pdf"),"}\\linebreak"))
}
fileConnection <- file(file.path(getwd(), "Plot", paste0("0sentixHerf.txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
rm(sPlot, sentixGroup, lateximport, fileConnection)
lapply(sHerf, function(x) {base::summary(x[,-1], digits = 2)})
## plot Data Black White (print)
library(tidyverse)
retPlotLong <- gather(retPlot, index, value, -Datum)
retPlotLong$index <- factor(retPlotLong$index)
bearMinMax <- data.frame("date" = c(min(datesEvalBear), max(datesEvalBear)))
RecNBERMinMax <- data.frame("date" = c(min(datesEvalRecNBER), max(datesEvalRecNBER)))
bullMinMax <- data.frame("date" = c(min(datesEvalBull), max(datesEvalBull)))
TestSplit <- data.frame("date" = min(datesEvalAllAfterTest))
pdf(file.path(getwd(), "Plot", paste0("retPlot-BW", ".pdf")), width = 10, height = 4)
ggplot(retPlotLong, aes(x = Datum, y=value, col=index, linetype = index)) +
geom_line(lwd=1) +
scale_color_grey() +
scale_linetype_discrete() +
geom_vline(data = bearMinMax, aes(xintercept=as.numeric(date)),
linetype=4, colour="black") +
geom_vline(data = RecNBERMinMax, aes(xintercept=as.numeric(date)),
linetype=3, colour="black") +
geom_vline(data = bullMinMax, aes(xintercept=as.numeric(date)),
linetype=2, colour="black") +
geom_vline(data = TestSplit, aes(xintercept=as.numeric(date)),
linetype=1, colour="black") +
theme_bw()+
labs(x = "Time", y = "Value", colour = "Index", linetype = "Index")
dev.off()
# rm(retPlot, cols, ylim)
## plot Data Black White (print)
library(tidyverse)
library(ggtern)
retPlotLong <- gather(retPlot, index, value, -Datum)
retPlotLong$index <- factor(retPlotLong$index)
bearMinMax <- data.frame("date" = c(min(datesEvalBear), max(datesEvalBear)))
RecNBERMinMax <- data.frame("date" = c(min(datesEvalRecNBER), max(datesEvalRecNBER)))
bullMinMax <- data.frame("date" = c(min(datesEvalBull), max(datesEvalBull)))
TestSplit <- data.frame("date" = min(datesEvalAllAfterTest))
pdf(file.path(getwd(), "Plot", paste0("retPlot", ".pdf")), width = 10, height = 4)
ggplot(retPlotLong, aes(x = Datum, y=value, col=index)) +
geom_line(lwd=1) +
# scale_color_grey() +
geom_vline(data = bearMinMax, aes(xintercept=as.numeric(date)),
linetype=4, colour="black") +
geom_vline(data = RecNBERMinMax, aes(xintercept=as.numeric(date)),
linetype=3, colour="black") +
geom_vline(data = bullMinMax, aes(xintercept=as.numeric(date)),
linetype=2, colour="black") +
geom_vline(data = TestSplit, aes(xintercept=as.numeric(date)),
linetype=1, colour="black") +
theme_rgbg() +
# theme_bw()+
labs(x = "Time", y = "Value", colour = "Index")
dev.off()
# rm(retPlot, cols, ylim)
retPlotLong <- gather(retPlot, index, value, -Datum)
retPlotLong$index <- factor(retPlotLong$index)
bearMinMax <- data.frame("date" = c(min(datesEvalBear), max(datesEvalBear)))
RecNBERMinMax <- data.frame("date" = c(min(datesEvalRecNBER), max(datesEvalRecNBER)))
bullMinMax <- data.frame("date" = c(min(datesEvalBull), max(datesEvalBull)))
TestSplit <- data.frame("date" = min(datesEvalAllAfterTest))
ggplot(retPlotLong, aes(x = Datum, y=value, col=index)) +
geom_line(lwd=1) +
# scale_color_grey() +
geom_vline(data = bearMinMax, aes(xintercept=as.numeric(date)),
linetype=4, colour="black") +
geom_vline(data = RecNBERMinMax, aes(xintercept=as.numeric(date)),
linetype=3, colour="black") +
geom_vline(data = bullMinMax, aes(xintercept=as.numeric(date)),
linetype=2, colour="black") +
geom_vline(data = TestSplit, aes(xintercept=as.numeric(date)),
linetype=1, colour="black") +
# theme_rgbg() +
theme_bw()+
labs(x = "Time", y = "Value", colour = "Index")
## plot Data Black White (print)
library(tidyverse)
library(ggtern)
retPlotLong <- gather(retPlot, index, value, -Datum)
retPlotLong$index <- factor(retPlotLong$index)
bearMinMax <- data.frame("date" = c(min(datesEvalBear), max(datesEvalBear)))
RecNBERMinMax <- data.frame("date" = c(min(datesEvalRecNBER), max(datesEvalRecNBER)))
bullMinMax <- data.frame("date" = c(min(datesEvalBull), max(datesEvalBull)))
TestSplit <- data.frame("date" = min(datesEvalAllAfterTest))
pdf(file.path(getwd(), "Plot", paste0("retPlot", ".pdf")), width = 10, height = 4)
## plot Data Black White (print)
library(tidyverse)
library(ggtern)
retPlotLong <- gather(retPlot, index, value, -Datum)
retPlotLong$index <- factor(retPlotLong$index)
bearMinMax <- data.frame("date" = c(min(datesEvalBear), max(datesEvalBear)))
RecNBERMinMax <- data.frame("date" = c(min(datesEvalRecNBER), max(datesEvalRecNBER)))
bullMinMax <- data.frame("date" = c(min(datesEvalBull), max(datesEvalBull)))
TestSplit <- data.frame("date" = min(datesEvalAllAfterTest))
pdf(file.path(getwd(), "Plot", paste0("retPlot", ".pdf")), width = 10, height = 4)
ggplot(retPlotLong, aes(x = Datum, y=value, col=index)) +
geom_line(lwd=1) +
# scale_color_grey() +
geom_vline(data = bearMinMax, aes(xintercept=as.numeric(date)),
linetype=4, colour="black") +
geom_vline(data = RecNBERMinMax, aes(xintercept=as.numeric(date)),
linetype=3, colour="black") +
geom_vline(data = bullMinMax, aes(xintercept=as.numeric(date)),
linetype=2, colour="black") +
geom_vline(data = TestSplit, aes(xintercept=as.numeric(date)),
linetype=1, colour="black") +
# theme_rgbg() +
theme_bw()+
labs(x = "Time", y = "Value", colour = "Index")
dev.off()
# rm(retPlot, cols, ylim)
ternary
ternary
ternary
srWeightsAn <- extractWeightsWithValue(xDispVarTestCalc, "anSR")
xDispVarTestCalc <- calcTestVar(xDispVarTest)
calcTestVar <- function(dat){
res <- list()
for(timeWindowName in names(dat)){
timeWindow <- get(timeWindowName)
retTimeWindow <- ret[timeWindow,]
retTimeWindow <- retTimeWindow[-1,]
colnames(retTimeWindow) <- colnames(ret)
rf <- mean(retTimeWindow[,"BUND"])
for(sentixGroup in names(dat[[timeWindowName]])){
for(goalWeight in names(dat[[timeWindowName]][[sentixGroup]])){
R <- rowSums(dat[[timeWindowName]][[sentixGroup]][[goalWeight]]$x * retTimeWindow)
r <- mean(R)
sd <- sd(R)
anR <- (1+r)^52-1
anSd <- sqrt((sd^2)*52)
fweight = mean(dat[[timeWindowName]][[sentixGroup]][[goalWeight]]$obj)
res[[timeWindowName]][[sentixGroup]][[goalWeight]] <- list(r = r, sd = sd, sr = r/sd,
anR = anR, anSd = anSd, anSR = anR/anSd,
fweight = fweight)
}
}
}
return(res)
}
xDispVarTestCalc <- calcTestVar(xDispVarTest)
xDispVarTest <- readRDS(file.path(getwd(), "Optimization", "EDispersionMinVaryingTest_gloggest2018-12-28---10-00"))
xDispVarTestCalc <- calcTestVar(xDispVarTest)
srWeightsAn <- extractWeightsWithValue(xDispVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Dispersion")
ternaryPlot <- function(dat, titleFile, bw=FALSE){
lateximport <- c(paste0("\\subsection{", titleFile, "}"))
for(t in names(dat$datesTest)){
dat3 <- dat$datesTest[[t]]
wmax <- dat3[which.max(dat3$value), c("w1", "w2", "w3", "value")]
plot(plotTernary(dat3, wmax))
print("yea")
title <- paste0(titleFile, "-", t, ".pdf")
pdf(file.path(getwd(), "Plot", title), width = 12, height = 10)
plot(plotTernary(dat3, wmax, bw))
dev.off()
lateximport <- c(lateximport, paste0("\\includegraphics[height=0.45\\textheight]{",title,"}\\linebreak"))
}
fileConnection <- file(file.path(getwd(), "Plot", paste0("0", titleFile, ".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
srWeightsAn <- extractWeightsWithValue(xDispVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Dispersion")
plotTernary <- function(dat3, wmax, bw=FALSE){
if(bw){
return(ggtern(dat3, aes(x=w1, y=w2, z=w3, value=value)) +
geom_point(shape=".")+
geom_text(aes(x=w1, y=w2, label=round(value,1)), data = dat3[dat3[["value"]]>(dat3[(dat3[["w1"]]==wmax$w1) & (dat3[["w2"]]==wmax$w2),"value"]*0.95),], color = "grey50") +
geom_interpolate_tern(aes(value=value, color = ..level..)) +
geom_point(aes(x=w1, y=w2), data = wmax, color = "black") +
geom_text(aes(x=w1, y=w2, label=round(value,1)), data = wmax, color = "black" )+
ternthemeBW() +
Lline(Lintercept =  wmax$w1, colour = "Black", linetype = 2, lwd=1) + ## w1 on Left axis
Tline(Tintercept = wmax$w2, colour = "Black", linetype = 2, lwd=1) + ## w2 on Top axis
Rline(Rintercept = wmax$w3, color = "Black", linetype = 2, lwd=1) + ## w3 on Right axis
scale_color_gradient(low = "grey90", high = "grey0") +
labs(x = "Return", y = "Volatility", z = "Disagreement",
color = "Level")
)
}else{
return(ggtern(dat3, aes(x=w1, y=w2, z=w3, value=value)) +
geom_point(shape=".")+
geom_text(aes(x=w1, y=w2, label=round(value,1)), data = dat3[dat3[["value"]]>(dat3[(dat3[["w1"]]==wmax$w1) & (dat3[["w2"]]==wmax$w2),"value"]*0.95),]) +
geom_interpolate_tern(aes(value=value, color = ..level..)) +
geom_point(aes(x=w1, y=w2), data = wmax, color = "red") +
geom_text(aes(x=w1, y=w2, label=round(value,1)), data = wmax, color = "red" ) +
terntheme() +
Lline(Lintercept =  wmax$w1, colour = theme_rgbg()$tern.axis.line.L$colour, linetype = 2, lwd=1) + ## w1 on Left axis
Tline(Tintercept = wmax$w2, colour = theme_rgbg()$tern.axis.line.T$colour, linetype = 2, lwd=1) + ## w2 on Top axis
Rline(Rintercept = wmax$w3, color = theme_rgbg()$tern.axis.line.R$colour, linetype = 2, lwd=1) + ## w3 on Right axis
scale_color_gradient(low = "green", high = "red") +
labs(x = "Return", y = "Volatility", z = "Disagreement",
color = "Level")
# labs(x = "return", y = "variation", z = "dispersion",
#      # title = paste0("Ternary Plot with Sharpe Ratio Contour Lines -", deparse(substitute(dat3)), "-", t),
#      color = "Level")
)
}
}
srWeightsAn <- extractWeightsWithValue(xDispVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Dispersion")
terntheme <- function(){
theme_rgbg() +
# theme_rgbw()+
theme(legend.position = c(0, 1),
legend.justification = c(0, 1),
plot.margin=unit(c(0, 2,0, 2), "cm"))
# tern.panel.background = element_rect(fill = "lightskyblue1")
}
ternthemeBW <- function(){
theme_bw() +
theme(legend.position = c(0, 1),
legend.justification = c(0, 1),
plot.margin=unit(c(0, 2,0, 2), "cm"))
}
srWeightsAn <- extractWeightsWithValue(xDispVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Dispersion")
srWeightsAn <- extractWeightsWithValue(xDispVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Dispersion")
ternaryPlot(srWeightsAn, "Ternary-Dispersion-BW", bw=TRUE)
>>>>>>> 6d4ae6e8a47fb898f75512b9f6405ec73c594a38

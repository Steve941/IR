}
wOptDispNoRFSRAn$datesTest
rm(xDispNoRFVarTest, xDispNoRFVarTestCalc)
# Herfindahl
targetHerf <- -0.50 ## found as it looks promising and reachable in the analysis (quite low in the reachable values)
hHerfDirectMin <- function(x){
y <- numeric(3)
y[1] <- -1.0 * w[1] * drop(crossprod(x, anMuOpt)) / targetRpa
y[2] <- w[2] * drop(sqrt(t(x) %*% anCOpt %*% x)) * sqrt(12) / targetVolpa
y[3] <- w[3] * drop(crossprod(x, anHOpt)) / targetHerf
return(sum(y))
}
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xHerfVarTest <- list()
registerDoSNOW(cl)
for(t in datesTestNames){
xHerfVarTest[[t]] <- foreach(i = names(sHerf), .export = c(datesTestNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
for(weightInd in 1:nrow(grid)){
w <- unlist(grid[weightInd,])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[i]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[i]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
L[[paste(w, collapse = "-")]] <- list(x = mat, obj = obj, time = tim)
print(weightInd/nrow(grid))
}
L
}
names(xHerfVarTest[[t]]) <- names(sHerf)
}
saveRDS(xHerfVarTest, file = file.path(getwd(), "Optimization", paste0("EHerfMinVaryingTest_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
stopCluster(cl)
xHerfVarTest <- readRDS(file.path(getwd(), "Optimization", "EHerfMinVaryingTest_gloggest2019-03-18---17-40"))
xHerfVarTestCalc <- calcTestVar(xHerfVarTest)
srWeightsAn <- extractWeightsWithValue(xHerfVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Herfindahl")
wOptHerfSRAn <- list()
for(timeWindowName in names(srWeightsAn)){
for(sentixGroup in names(srWeightsAn[[timeWindowName]])){
df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptHerfSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptHerfSRAn$datesTest
rm(xHerfVarTest, xHerfVarTestCalc)
# Herfindahl
targetHerf <- -0.50 ## found as it looks promising and reachable in the analysis (quite low in the reachable values)
hHerfDirectMin <- function(x){
y <- numeric(3)
y[1] <- -1.0 * w[1] * drop(crossprod(x, anMuOpt)) / targetRpa
y[2] <- w[2] * drop(sqrt(t(x) %*% anCOpt %*% x)) * sqrt(12) / targetVolpa
y[3] <- w[3] * drop(crossprod(x, anHOpt)) / targetHerf
return(sum(y))
}
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xHerfNoRFVarTest <- list()
registerDoSNOW(cl)
for(t in datesTestNames){
xHerfNoRFVarTest[[t]] <- foreach(i = names(sHerf), .export = c(datesTestNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
for(weightInd in 1:nrow(grid)){
w <- unlist(grid[weightInd,])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[i]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[i]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
L[[paste(w, collapse = "-")]] <- list(x = mat, obj = obj, time = tim)
print(weightInd/nrow(grid))
}
L
}
names(xHerfNoRFVarTest[[t]]) <- names(sHerf)
}
saveRDS(xHerfNoRFVarTest, file = file.path(getwd(), "Optimization", paste0("EHerfNoRFMinVaryingTest_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
stopCluster(cl)
xHerfNoRFVarTest <- readRDS(file.path(getwd(), "Optimization", "EHerfNoRFMinVaryingTest_gloggest2018-12-28---09-12"))
xHerfNoRFVarTestCalc <- calcTestVar(xHerfNoRFVarTest)
xHerfNoRFVarTest <- readRDS(file.path(getwd(), "Optimization", "EHerfNoRFMinVaryingTest_gloggest2019-03-18---17-47"))
xHerfNoRFVarTestCalc <- calcTestVar(xHerfNoRFVarTest)
xHerfNoRFVarTestCalc <- calcTestVar(xHerfNoRFVarTest)
srWeightsAn <- extractWeightsWithValue(xHerfNoRFVarTestCalc, "anSR")
ternaryPlot(srWeightsAn, "Ternary-Herfindahl-No-Risk-free")
wOptHerfNoRFSRAn <- list()
for(timeWindowName in names(srWeightsAn)){
for(sentixGroup in names(srWeightsAn[[timeWindowName]])){
df <- srWeightsAn[[timeWindowName]][[sentixGroup]]
wOptHerfNoRFSRAn[[timeWindowName]][[sentixGroup]] <- df[which.max(df$value), c("w1", "w2", "w3")]
}
}
wOptHerfNoRFSRAn$datesTest
rm(xHerfNoRFVarTest, xHerfNoRFVarTestCalc)
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xDispVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xDispVarEval[[t]] <- foreach(sentixGroup = names(sDisp), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptDispSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xDispVarEval[[t]]) <- names(sDisp)
}
stopCluster(cl)
# names(xDispVarTest) <- datesTestNames
saveRDS(xDispVarEval, file = file.path(getwd(), "Optimization", paste0("EDispersionMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xDispNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xDispNoRFVarEval[[t]] <- foreach(sentixGroup = names(sDisp), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptDispNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <-  as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anDOpt <- as.numeric(sDisp[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hDispDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xDispNoRFVarEval[[t]]) <- names(sDisp)
}
stopCluster(cl)
# names(xDispVarTest) <- datesTestNames
saveRDS(xDispNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EDispersionNoRFMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores) # use server fully
} else
stop("Who are you???")
xHerfVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xHerfVarEval[[t]] <- foreach(sentixGroup = names(sHerf), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptHerfSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xHerfVarEval[[t]]) <- names(sHerf)
}
stopCluster(cl)
# names(xHerfVarTest) <- datesTestNames
saveRDS(xHerfVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
k <- 50
cores <- detectCores()
if(Sys.getenv("USERNAME") == "Stefan"){
cl <- makeCluster(cores - 1)
} else if(Sys.getenv("USERNAME") == "gloggest"){
cl <- makeCluster(cores-1) # use server fully
} else
stop("Who are you???")
xHerfNoRFVarEval <- list()
registerDoSNOW(cl)
for(t in datesEvalNames){
# timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window ### not used any more, as we move up to actual date
xHerfNoRFVarEval[[t]] <- foreach(sentixGroup = names(sHerf), .export = c(datesEvalNames), .packages = c("Rdonlp2")) %dopar%{
L <- list()
w <- unlist(wOptHerfNoRFSRAn$datesTest[[sentixGroup]])
mat <- matrix(NA, nrow = (length(get(t))-1), ncol = ncol(ret))
colnames(mat) <- colnames(ret)
rownames(mat) <- get(t)[1:(length(get(t))-1)]
obj <- numeric(length(get(t))-1)
tim <- numeric(length(get(t))-1)
# first separate to then use the previous solution as starting point for next solution
### -------------------
j <- 1
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <-  as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = rep(1/ncol(retOpt), ncol(retOpt)), fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[1,] <- erg$solution
obj[1] <- erg$objective
tim[1] <- as.numeric(erg$elapsed)
### -------------------
for(j in 2:(length(get(t))-1)){
tInd <- which(datesAll == get(t)[j])
retOpt <- ret[(tInd-k+1):tInd,]
anMuOpt <- (1+colMeans(retOpt))^52-1
anCOpt <- cov(retOpt)*52
anHOpt <- as.numeric(sHerf[[sentixGroup]][tInd,-1])
erg <- donlp2NLP(start = mat[j-1,], fun = hHerfDirectMin,
par.lower = rep(0, ncol(retOpt)), ineqA = IneqA,
ineqA.lower = 1.0, ineqA.upper = 1.0,
eqA = c(rep(0, ncol(retOpt)-1), 1), eqA.bound = 0) # set last to zero (BUND, risk free)
mat[j,] <- erg$solution
obj[j] <- erg$objective
tim[j] <- as.numeric(erg$elapsed)
}
list(x = mat, obj = obj, time = tim)
}
names(xHerfNoRFVarEval[[t]]) <- names(sHerf)
}
stopCluster(cl)
# names(xHerfVarTest) <- datesTestNames
saveRDS(xHerfNoRFVarEval, file = file.path(getwd(), "Optimization", paste0("EHerfNoRFMinVaryingEval_", Sys.getenv("USERNAME"), format(Sys.time(), "%Y-%m-%d---%H-%M"))))
rm(grid, IneqA)
rm(plotTernary, terntheme, ternaryPlot, calcTestVar)
detach("package:doSNOW", unload = T)
unloadNamespace("doParallel")
detach("package:parallel", unload = T)
detach("package:foreach", unload = T)
detach("package:ggtern", unload = T)
library(fPortfolio)
library(FRAPO)
xClassicConst <- list()
# convert rownames back to date format (character!)
t <- rownames(ret)
class(t) <- "Date"
rdatTimeSource <- timeSeries(ret, charvec = as.character(t))
# equal weights to start with (maybe)
ew <- rep(1/ncol(ret), ncol(ret))
for(t in datesEvalNames){
timeInd <- datesAll[which(datesAll == min(get(t)))-1] ## one day before start of time window
rdatTime <- window(rdatTimeSource, start = start(rdatTimeSource), end = timeInd) # note: first day is missing as returns miss first day of datesAll (naturally as no return at start)
ans <- tangencyPortfolio(rdatTime)
xClassicConst[[t]][["tanPort"]] <- getWeights(ans)
ans <- minvariancePortfolio(rdatTime)
xClassicConst[[t]][["mVaPort"]] <- getWeights(ans)
C <- cov(rdatTime)
ans <- rp(ew, C, ew, optctrl = ctrl(trace = FALSE))
xClassicConst[[t]][["rp"]] <- c(getx(ans))
ans <- PGMV(rdatTime, optctrl = ctrl(trace = FALSE))
xClassicConst[[t]][["PGMV"]] <- Weights(ans) / 100
ans <- PMD(rdatTime, optctrl = ctrl(trace = FALSE))
xClassicConst[[t]][["PMD"]] <- Weights(ans) / 100
xClassicConst[[t]][["ew"]] <- ew
}
rm(rdatTime, rdatTimeSource, t, ew, ans)
k <- 50
xClassicVar <- list()
# convert rownames back to date format (character!)
t <- rownames(ret)
class(t) <- "Date"
rdatTimeSource <- timeSeries(ret, charvec = as.character(t))
# equal weights to start with (maybe)
ew <- rep(1/ncol(ret), ncol(ret))
for(timeWindowName in datesEvalNames){
datesEvalNow <- get(timeWindowName)
mat <- matrix(NA, nrow = (length(datesEvalNow)-1), ncol = ncol(rdatTimeSource))
colnames(mat) <- colnames(ret)
rownames(mat) <- datesEvalNow[1:(length(datesEvalNow)-1)]
xClassicVar[[timeWindowName]][["tanPort"]]$x <- mat
xClassicVar[[timeWindowName]][["mVaPort"]]$x <- mat
xClassicVar[[timeWindowName]][["rp"]]$x <- mat
xClassicVar[[timeWindowName]][["PGMV"]]$x <- mat
xClassicVar[[timeWindowName]][["PMD"]]$x <- mat
xClassicVar[[timeWindowName]][["ew"]]$x <- mat
for(d in 1:(length(datesEvalNow)-1)){ # last date no portfolio weights
timeEndInd <- which(datesAll == datesEvalNow[d]) ## one day before start of time window => NO, we can go up to the date
timeEnd <- datesAll[timeEndInd]
timeStart <- datesAll[timeEndInd-k+1]
rdatTime <- timeSeries::window(rdatTimeSource, start = timeStart, end = timeEnd) # note: first day is missing as returns miss first day of datesAll (naturally as no return at start)
ans <- tangencyPortfolio(rdatTime)
xClassicVar[[timeWindowName]][["tanPort"]]$x[d,] <- getWeights(ans)
ans <- minvariancePortfolio(rdatTime)
xClassicVar[[timeWindowName]][["mVaPort"]]$x[d,] <- getWeights(ans)
C <- cov(rdatTime)
ans <- rp(ew, C, ew, optctrl = ctrl(trace = FALSE))
xClassicVar[[timeWindowName]][["rp"]]$x[d,] <- c(getx(ans))
ans <- PGMV(rdatTime, optctrl = ctrl(trace = FALSE))
xClassicVar[[timeWindowName]][["PGMV"]]$x[d,] <- Weights(ans) / 100
ans <- PMD(rdatTime, optctrl = ctrl(trace = FALSE))
xClassicVar[[timeWindowName]][["PMD"]]$x[d,] <- Weights(ans) / 100
xClassicVar[[timeWindowName]][["ew"]]$x[d,] <- ew
}
}
rm(t, timeEnd, timeEndInd, timeStart, timeWindowName, k, ew, rdatTime, rdatTimeSource, ans)
k <- 50
xClassicVarNoRf <- list()
# convert rownames back to date format (character!)
t <- rownames(ret)
class(t) <- "Date"
rdatTimeSource <- timeSeries(ret, charvec = as.character(t))
# equal weights to start with (maybe)
ew <- rep(1/(ncol(ret)-1), (ncol(ret)-1))
for(timeWindowName in datesEvalNames){
datesEvalNow <- get(timeWindowName)
mat <- matrix(NA, nrow = (length(datesEvalNow)-1), ncol = ncol(rdatTimeSource))
colnames(mat) <- colnames(ret)[1:ncol(rdatTimeSource)]
rownames(mat) <- datesEvalNow[1:(length(datesEvalNow)-1)]
xClassicVarNoRf[[timeWindowName]][["tanPort"]]$x <- mat
xClassicVarNoRf[[timeWindowName]][["mVaPort"]]$x <- mat
xClassicVarNoRf[[timeWindowName]][["rp"]]$x <- mat
xClassicVarNoRf[[timeWindowName]][["PGMV"]]$x <- mat
xClassicVarNoRf[[timeWindowName]][["PMD"]]$x <- mat
xClassicVarNoRf[[timeWindowName]][["ew"]]$x <- mat
for(d in 1:(length(datesEvalNow)-1)){ # last date no portfolio weights
timeEndInd <- which(datesAll == datesEvalNow[d]) ## one day before start of time window => NO, we can go up to the date
timeEnd <- datesAll[timeEndInd]
timeStart <- datesAll[timeEndInd-k+1]
rdatTime <- timeSeries::window(rdatTimeSource, start = timeStart, end = timeEnd) # note: first day is missing as returns miss first day of datesAll (naturally as no return at start)
rf <- mean(rdatTime[,"BUND"])
rdatTime <- rdatTime[,setdiff(names(rdatTime), "BUND")] # reduce to all but BUND
portfolio <- portfolioSpec()
setRiskFreeRate(portfolio) <- rf
ans <- tangencyPortfolio(rdatTime, spec = portfolio)
xClassicVarNoRf[[timeWindowName]][["tanPort"]]$x[d,] <- c(getWeights(ans), 0)
ans <- minvariancePortfolio(rdatTime, spec = portfolio)
xClassicVarNoRf[[timeWindowName]][["mVaPort"]]$x[d,] <- c(getWeights(ans), 0)
C <- cov(rdatTime)
ans <- rp(ew, C, ew, optctrl = ctrl(trace = FALSE))
xClassicVarNoRf[[timeWindowName]][["rp"]]$x[d,] <- c(getx(ans), 0)
ans <- PGMV(rdatTime, optctrl = ctrl(trace = FALSE))
xClassicVarNoRf[[timeWindowName]][["PGMV"]]$x[d,] <- c(Weights(ans) / 100, 0)
ans <- PMD(rdatTime, optctrl = ctrl(trace = FALSE))
xClassicVarNoRf[[timeWindowName]][["PMD"]]$x[d,] <- c(Weights(ans) / 100, 0)
xClassicVarNoRf[[timeWindowName]][["ew"]]$x[d,] <- c(ew, 0)
}
}
rm(t, timeEnd, timeEndInd, timeStart, timeWindowName, k, ew, rdatTime, rdatTimeSource, ans)
detach("package:FRAPO", unload = T)
detach("package:fPortfolio", unload = T)
detach("package:fAssets", unload = T)
unloadNamespace("fCopulae")
unloadNamespace("fMultivar")
detach("package:fBasics", unload = T) # need to unload "fCopulae" and "fMultivar" first, somehow "detach" doesn't work -> use "unloadNamespace()"
detach("package:timeSeries", unload = T)

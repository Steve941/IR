---
title: "Visualization"
author: "Stefan Glogger"
date: "August 2017"
output: pdf_document
---


```{r, include=FALSE}
source("parameters.R")
```

```{r, include=FALSE, cache=T, results='hide'}
knitr::knit_child("50 Optimization.Rmd")
```

# Visualization

## One Dispersion, different weights

We visualize the different portfolio returns of each time window of each dispersion in a histogram.

The results can (also) be found in "\\IR-Phase FIM-Statistik\\R-Research Project Statistics\\Plot Optimization\\Dispersion Const".

### on its own

not so interesting, nicer below

```{r}
for(d in datesNames){
    retOverTime <- apply(1+ret[get(d),], 2, prod)
    
    for(i in names(xDispConst[[d]])){
        retDispTime <- numeric(length(xDispConst[[d]][[i]]))
        names(retDispTime) <- names(xDispConst[[d]][[i]])
        for(j in 1:length(retDispTime)){
            retDispTime[j] <- crossprod(xDispConst[[d]][[i]][[j]]$x, retOverTime)
        }
        
        t <- paste(d, i, sep = " - ")
        pdf(file.path(getwd(), "Plot Optimization", "Dispersion Const", paste0(t, ".pdf")), width = 10, height = 4)
        plot(retDispTime, main = t)
        dev.off()
    }
}
```

### together (all different dispersions)

```{r}
for(d in datesNames){
    cols <- rainbow(length(xDispConst[[d]]))
    retOverTime <- apply(1+ret[get(d),], 2, prod)
    retDispTime <- data.frame(w = names(xDispConst[[d]][[1]]))
    
    for(i in names(xDispConst[[d]])){
        for(j in 1:nrow(retDispTime)){
            retDispTime[j,i] <- crossprod(xDispConst[[d]][[i]][[j]]$x, retOverTime)
        }
    }
    
    ylim = c(min(retDispTime[,-1]), max(retDispTime[,-1]))
    plot(retDispTime[,2], ylim = ylim, col = cols[1], main = d)
    for(i in 3:ncol(retDispTime)){
        par(new=T)
        plot(retDispTime[,i], ylim = ylim, axes = F, xlab = "", ylab = "", col = cols[i-1])
    }
    legend("bottomright", legend = names(xDispConst[[d]]), col = cols, lty = 1)
    
    pdf(file.path(getwd(), "Plot Optimization", "Dispersion Const", paste0("0", d, ".pdf")), width = 10, height = 8)
    plot(retDispTime[,2], ylim = ylim, col = cols[1], main = d)
    for(i in 3:ncol(retDispTime)){
        par(new=T)
        plot(retDispTime[,i], ylim = ylim, axes = F, xlab = "", ylab = "", col = cols[i-1])
    }
    legend("bottomright", legend = names(xDispConst[[d]]), col = cols, lty = 1)
    dev.off()
}

```

## Classic Optimization

### Constant weights over window

We want to visualize the evolvement of a portfolio over each time window.

Be aware of the index shifting:
retPlot[j-1, i] take wealth of previous day
retOverTime[j-1,] take return of today (j is one step ahead)

Remove numbering of x-axis by *xaxt='n'*.

```{r}
for(d in datesEvalNames){
    cols <- rainbow(length(xClassicConst[[d]]))
    retOverTime <- 1+ret[get(d),]
    retPlotDates <- get(d)
    retPlotDates <- c(datesAll[which(datesAll==min(retPlotDates))-1], retPlotDates)
    retPlot <- data.frame(Datum = retPlotDates)
    
    for(i in names(xClassicConst[[d]])){
        retPlot[1,i] <- 100
        for(j in 2:nrow(retPlot)){
            retPlot[j,i] <- retPlot[j-1,i]*crossprod(xClassicConst[[d]][[i]], retOverTime[j-1,])
        }
    }
    
    ylim = c(min(retPlot[,-1]), max(retPlot[,-1]))
    plot(retPlot[,2], type = "l", ylim = ylim, col = cols[1], main = d, xlab = "Date", ylab = "Value", xaxt='n')
    for(i in 3:ncol(retPlot)){
        par(new=T)
        plot(retPlot[,i], type = "l", ylim = ylim, axes = F, xlab = "", ylab = "", col = cols[i-1])
    }
    axis(1, at = c(0, 10, 20, 30, 40, 50), labels = retPlot[c(0, 10, 20, 30, 40, 50)+1,1])
    legend("bottomright", legend = names(xClassicConst[[d]]), col = cols, lty = 1)
    
    pdf(file.path(getwd(), "Plot Optimization", "Classical Const", paste0(d, ".pdf")), width = 10, height = 8)
    plot(retPlot[,2], type = "l", ylim = ylim, col = cols[1], main = d, xlab = "Date", ylab = "Value", xaxt='n')
    for(i in 3:ncol(retPlot)){
        par(new=T)
        plot(retPlot[,i], type = "l", ylim = ylim, axes = F, xlab = "", ylab = "", col = cols[i-1])
    }
    axis(1, at = c(0, 10, 20, 30, 40, 50), labels = retPlot[c(0, 10, 20, 30, 40, 50)+1,1])
    legend("bottomright", legend = names(xClassicConst[[d]]), col = cols, lty = 1)
    dev.off()
}
```

## Sentix Optimization

### Change of Portfolio weights

First, we want to depict the change of portfolio weights over time.

#### area plot

We want to generate an area plot of the varying weights.

```{r}
dat = xSentixVarying$datesEvalBear$P1$x

plotWeightsArea <- function(datName){
    dat <- datName$x
    alpha = 0.5 
    rn <- rownames(dat)
    dat <- t(apply(dat, 1, cumsum))
    dat <- as.data.frame(dat)
    dat$date <- as.Date(rownames(dat))
    
    ggplot(dat, aes(x=date)) +
        geom_area(aes(y=dat[,7], fill=colnames(dat)[7]), alpha=alpha) +
        geom_area(aes(y=dat[,6], fill=colnames(dat)[6]), alpha=alpha) +
        geom_area(aes(y=dat[,5], fill=colnames(dat)[5]), alpha=alpha) +
        geom_area(aes(y=dat[,4], fill=colnames(dat)[4]), alpha=alpha) +
        geom_area(aes(y=dat[,3], fill=colnames(dat)[3]), alpha=alpha) +
        geom_area(aes(y=dat[,2], fill=colnames(dat)[2]), alpha=alpha) +
        geom_area(aes(y=dat[,1], fill=colnames(dat)[1]), alpha=alpha) +
        scale_fill_discrete(name="Index") +
        labs(title = deparse(substitute(datName)),
             y = "Weight",
             x = "Date")
}

plotWeightsArea(xSentixVarying[["datesEvalBear"]][["P1"]])
```

#### Line Plot

As the area might be a bit complicated to understand (just the visible height of the area matters, not the absolute maximal y value), we use a line plot for visualization.

```{r}
plotWeightsLines <- function(datName, d, s){
    dat <- datName[[d]][[s]]$x
    rn <- rownames(dat)
    dat <- as.data.frame(dat)
    dat$date <- as.Date(rownames(dat))
    
    ggplot(dat, aes(x=date)) +
        geom_line(aes(y=dat[,7], color = colnames(dat)[7])) +
        geom_line(aes(y=dat[,6], color = colnames(dat)[6])) +
        geom_line(aes(y=dat[,5], color = colnames(dat)[5])) +
        geom_line(aes(y=dat[,4], color = colnames(dat)[4])) +
        geom_line(aes(y=dat[,3], color = colnames(dat)[3])) +
        geom_line(aes(y=dat[,2], color = colnames(dat)[2])) +
        geom_line(aes(y=dat[,1], color = colnames(dat)[1])) +
        labs(title = paste("Time:", d),
             subtitle = paste("SentixGroup:", s),
             y = "Weight",
             x = "Date") +
        scale_color_discrete(name = "Index")
}
```

```{r}
for(d in datesEvalNames){
    for(s in names(xSentixVarying[[d]])){
        # plotWeightsLines(xSentixVarying, d, s)
        
        pdf(file.path(getwd(), "Plot", paste0("Weights-", d,"-", s, ".pdf")), width = 10, height = 4)
        plot(plotWeightsLines(xSentixVarying, d, s))
        dev.off()
    }
}
```

### Resulting Portfolios

We want to visualize the evolvement of a portfolio over each time window.

Be aware of the index shifting:
retPlot[j-1, i] take wealth of previous day
retOverTime[j-1,] take return of today (j is one step ahead)

Remove numbering of x-axis by *xaxt='n'*.

Generate *retPortSentixVarying*, the returns of portfolios with varying portfolio weights using sentix as third factor with optimal weights. It has the following structure:

time window -> dispersion (sentixGroup) -> return of Portfolio, sharpe ratio

R: return of portfolio on each date
r: mean return of portfolio over whole time window
sd: standard deviation of return of portfolio over whole time window
sr: sharpe ratio (weekly)
anR: annualized return of portfolio over whole time window
anSd: annualized standard deiation
anSR: sharpe ratio (annual)
fweight: mean of goal function value

Use an adoption of *calcTestVar()*

```{r}
calcEvalVar <- function(dat){
    res <- list()
    for(timeWindowName in names(dat)){
        timeWindow <- get(timeWindowName)
        retTimeWindow <- ret[timeWindow,]
        retTimeWindow <- retTimeWindow[-1,]
        colnames(retTimeWindow) <- colnames(ret)
        
        rf <- mean(retTimeWindow[,"BUND"])
        
        for(sentixGroupName in names(dat[[timeWindowName]])){
            
            
            R <- rowSums(dat[[timeWindowName]][[sentixGroupName]]$x * retTimeWindow)
            
            r <- mean(R)
            sd <- sd(R)
            
            anR <- (1+r)^52-1
            anSd <- sqrt((sd^2)*52)
            
            fweight = mean(dat[[timeWindowName]][[sentixGroupName]]$obj)
            
            res[[timeWindowName]][[sentixGroupName]] <- list(R = R, r = r, sd = sd, sr = r/sd,
                                                                           anR = anR, anSd = anSd, anSR = anR/anSd,
                                                                           fweight = fweight)
            
        }
    }
    return(res)
}
```


```{r}
retPortSentixVarying <- calcEvalVar(xSentixVarying)
```

We now optimize the plotting for ggplot().

DOESN'T WORK

Therefore our dataframe to plot should have the following structure:
date: Date
value: worth of Portfolio
portfolio: Portfolio (SentixGroup)

first in separate list, then in one dataframe

NOTE: returns occur one date later as stated here (in the data)

```{r}
plotPortfolio <- function(dat, timeWindowName){
    datWork <- dat[[timeWindowName]]
    timeWindow <- get(timeWindowName)
    retTemp <- list()
    
    retPlot <- data.frame(date = get(timeWindowName))
    
    
    
    for(s in names(datWork)){
        ret <- cumprod(1+datWork[[s]]$R)
        retPlot[[s]] <- c(100, 100*ret)
    }
    retPlot$date <- as.Date(retPlot$date)
    
    for(s in names(datWork)){
        retTemp[[s]] <- data.frame(date = get(timeWindowName)[1])
        retTemp[[s]]$value <- as.numeric(100.0)
        retTemp[[s]]$portfolio <- as.character(names(datWork)[1])
        
        for(j in 1:length(datWork[[s]]$R)){
            retTemp[[s]] <- rbind(retTemp[[s]], list(timeWindow[j+1], unlist(retTemp[[s]][j,"value"]*(1+datWork[[s]]$R[j])), s))
        }
    }
    retPlot <- retTemp[[1]]
    for(j in 2:length(retTemp)){
        retPlot <- rbind(retPlot, retTemp[[j]])
    }
    retPlot$Datum <- as.Date(retPlot$date)
    retPlot$DatumInt <- as.integer(retPlot$date)
    
    ggplot(retPlot, aes(x=DatumInt)) +
        geom_line(aes(y=retPlot[,7], color = colnames(retPlot)[7])) +
        geom_line(aes(y=retPlot[,6], color = colnames(retPlot)[6])) +
        geom_line(aes(y=retPlot[,5], color = colnames(retPlot)[5])) +
        geom_line(aes(y=retPlot[,4], color = colnames(retPlot)[4])) +
        geom_line(aes(y=retPlot[,3], color = colnames(retPlot)[3])) +
        geom_line(aes(y=retPlot[,2], color = colnames(retPlot)[2])) +
        labs(title = paste("Time:", timeWindowName),
             y = "Value",
             x = "Date") +
        scale_color_discrete(name = "Index")
}

```

```{r}
plotPortfolio <- function(dat, timeWindowName){
    datWork <- dat[[timeWindowName]]
    timeWindow <- get(timeWindowName)
    
    
    
    ggplot(retPlot, aes(x=date)) +
        geom_line()
}
```







```{r}
for(d in datesEvalNames){
    plotPortfolio(retPortSentixVarying, d)
}

for(d in datesEvalNames){
    cols <- rainbow(length(xClassicConst[[d]]))
    retOverTime <- 1+ret[get(d),]
    retPlotDates <- get(d)
    retPlotDates <- c(datesAll[which(datesAll==min(retPlotDates))-1], retPlotDates)
    retPlot <- data.frame(Datum = retPlotDates)
    
    for(i in names(xClassicConst[[d]])){
        retPlot[1,i] <- 100
        for(j in 2:nrow(retPlot)){
            retPlot[j,i] <- retPlot[j-1,i]*crossprod(xClassicConst[[d]][[i]], retOverTime[j-1,])
        }
    }
    
    ylim = c(min(retPlot[,-1]), max(retPlot[,-1]))
    plot(retPlot[,2], type = "l", ylim = ylim, col = cols[1], main = d, xlab = "Date", ylab = "Value", xaxt='n')
    for(i in 3:ncol(retPlot)){
        par(new=T)
        plot(retPlot[,i], type = "l", ylim = ylim, axes = F, xlab = "", ylab = "", col = cols[i-1])
    }
    axis(1, at = c(0, 10, 20, 30, 40, 50), labels = retPlot[c(0, 10, 20, 30, 40, 50)+1,1])
    legend("bottomright", legend = names(xClassicConst[[d]]), col = cols, lty = 1)
    
    pdf(file.path(getwd(), "Plot Optimization", "Classical Const", paste0(d, ".pdf")), width = 10, height = 8)
    plot(retPlot[,2], type = "l", ylim = ylim, col = cols[1], main = d, xlab = "Date", ylab = "Value", xaxt='n')
    for(i in 3:ncol(retPlot)){
        par(new=T)
        plot(retPlot[,i], type = "l", ylim = ylim, axes = F, xlab = "", ylab = "", col = cols[i-1])
    }
    axis(1, at = c(0, 10, 20, 30, 40, 50), labels = retPlot[c(0, 10, 20, 30, 40, 50)+1,1])
    legend("bottomright", legend = names(xClassicConst[[d]]), col = cols, lty = 1)
    dev.off()
```

